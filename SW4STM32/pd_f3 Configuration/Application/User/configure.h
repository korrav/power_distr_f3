/*
 * configure.h
 *
 *  Created on: 10 янв. 2016 г.
 *      Author: andrej
 */

#ifndef APPLICATION_USER_CONFIGURE_H_
#define APPLICATION_USER_CONFIGURE_H_
#include <stdint.h>
#include <stdbool.h>

struct Sample {			//структура, содержащая параметры одного отсчёта
	uint16_t iMad[3];
	uint16_t u48v;
	uint16_t u300v;
};

struct MCur {	//конфигурация безопасности тока МАД
	uint16_t max;	//верхняя граница безопасного значения тока потребления
	uint16_t time_overh;	//количество отсчётов, которое ток потребления может находится за границей max, прежде чем сработает сигнал тревоги
};

struct Volt {
	uint16_t max;	//верхняя граница безопасного значения напряжения питания
	uint16_t min;	//нижняя граница безопасного значения напряжения питания
	uint16_t time_overh;	//количество отсчётов, которое напряжение питания может находится за границей безопасного режима, прежде чем сработает сигнал тревоги
};
struct SecConfigure {	//конфигурация безопасности
	struct MCur mads[3];	//токи потребления МАД
	struct Volt v_48;	//напряжение 48В
	struct Volt v_300; //напряжение 300В
};

struct MonitSwitchMode {	//отслеживание переключения мониторируемого параметра из безопасного в небезобасный режим и обратно
	bool isSecMode;	//парметр находится в безопасном режиме, если true, иначе - в небезопасном режиме
	uint16_t whileInOthMode;	//показывает сколько отсчётов непрерывно находится параметр в другом нежели isSecureMode режиме (значение декрементируется)
};

struct MonitSwitchModeParams {	//отслеживание переключения всех мониторируемых параметров из безопасного в небезобасный режим и обратно
	struct MonitSwitchMode mCur[3];	//мониторинг токов МАД
	struct MonitSwitchMode v_48;	//мониторинг напряжения 48В
	struct MonitSwitchMode v_300;	//мониторинг напряжения 300В
};

enum SWITCH_MODE {
	NO_CHANGE,	//режим не изменился
	MOVE_TO_SEC_MODE,	//перешёл в безопасный режим
	MOVE_TO_UNSEC_MODE,	//перешёл в небезопасный режим
};

union I2cMes {
	uint32_t blob;
	struct {	//структура  обычного сообщения I2C
		uint16_t id;	//идентификатор сообщения
		uint16_t arg;	//параметр
	} frame;
};
enum ID_I2C_MES {	//идентификаторы обычных сообщений I2C
	MES_VOLT_48V_TO_SEC_MODE,	//мониторируемое напряжение 48В перешло в состояние безопасного режима (в качестве параметра текущий отсчёт)
	MES_VOLT_48V_TO_UNSEC_MODE,	//мониторируемое напряжение 48В перешло в состояние небезопасного режима (в качестве параметра текущий отсчёт)
	MES_VOLT_300V_TO_SEC_MODE,	//мониторируемое напряжение 300В перешло в состояние безопасного режима (в качестве параметра текущий отсчёт)
	MES_VOLT_300V_TO_UNSEC_MODE, //мониторируемое напряжение 300В перешло в состояние небезопасного режима (в качестве параметра текущий отсчёт)
	MES_MONIT_NOT_TIME,	//мониторинговая программа не успевает обрабатывать данные при текущей скорости потока
	MES_OVR_ADC,	//DMA не успевает забирать данные из входного буфера АЦП
	MES_SPI_TRANS_NOT_TIME,	//передача данных  в SPI порт не успевает вовремя закончится при текущей скорости потока
	MES_GET_CONFIGURE,	//запрос о получении конфигурации безопасности
	MES_DISABLE_TRANS_MONIT_DATA,	//запрет передачи мониторной информации
	MES_ENABLE_TRANS_MONIT_DATA,	//разрешение передачи мониторной информации
	MES_START_MONIT_DATA,	//старт оцифровки мониторной информации по питанию
};

struct StatusMonitData {
	bool isTransDataToSpi;	//разрешение передачи данных на SPI порт (в пределах задачи должна изменяться только в критических секциях)
	bool isValidConfig;	//структура конфигурации безопасности подлинная
};

#define NUM_ELEM_BUF_DATA 5000	//количество элементов буфера данных (должно быть кратно 5)
#define TIME_TRANS_REQ_CONFIGURE  1000000 		// значение периода времени запрос конфигурации безопасности после включения МК (в мкс)
#define MAX_VAL_COUNT_LEAD 3 //максимальное значение счётчика инкрементирования
#define I2C_ADDR_HOST_MCU 8	//I2C адрес управляющего МК
#define I2C_ADDR_CONF 6	//I2C адрес получения конфигурации безопасности
#define I2C_ADDR_COM 2	//I2C адрес получения команд

//function
void ADCIntCallback(void);	//вызывается в подпрограмме прерывания ADC
void getInfoBufConf(uint8_t** addr, size_t* pSize); //получить информацию об адресе и размере буфера для сохранения нового значения структуры безопасности
void getInfoBufCom(uint8_t** addr, size_t* pSize);	////получить информацию об адресе и размере буфера для сохранения очередной команды, пришедшей по i2c
void setIdentBlockDataComForI2c(uint32_t ident); //установить идентификатор блока данных, пришедшего по i2c
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);	//функция обратного вызова, срабатывающая на сигнал запрета передачи I2C
void setTestPinPB1(void);
void setTestPinPA8(void);
#endif /* APPLICATION_USER_CONFIGURE_H_ */
